"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[495],{7317:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var i=t(4848),s=t(8453);const r={sidebar_position:1},a="Primitive Metric Types",c={id:"metrics/primitive-metric-types",title:"Primitive Metric Types",description:"For more detailed information on building metrics see the [Metrics DSL] section.",source:"@site/target/mdoc/metrics/primitive-metric-types.md",sourceDirName:"metrics",slug:"/metrics/primitive-metric-types",permalink:"/prometheus4cats/docs/metrics/primitive-metric-types",draft:!1,unlisted:!1,editUrl:"https://github.com/permutive-engineering/prometheus4cats/edit/main/website/docs/metrics/primitive-metric-types.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Metric Registry",permalink:"/prometheus4cats/docs/interface/metric-registry"},next:{title:"Derived Metric Types",permalink:"/prometheus4cats/docs/metrics/derived-metric-types"}},o={},l=[{value:"<code>Counter</code>",id:"counter",level:2},{value:"<code>Gauge</code>",id:"gauge",level:2},{value:"<code>Histogram</code>",id:"histogram",level:2},{value:"User Defined Buckets",id:"user-defined-buckets",level:3},{value:"Generated Buckets",id:"generated-buckets",level:3},{value:"<code>Summary</code>",id:"summary",level:2},{value:"Quantiles",id:"quantiles",level:3},{value:"Maximum Age and Age Buckets",id:"maximum-age-and-age-buckets",level:3},{value:"<code>Info</code>",id:"info",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"primitive-metric-types",children:"Primitive Metric Types"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["For more detailed information on building metrics see the ",(0,i.jsx)(n.a,{href:"/prometheus4cats/docs/interface/dsl",children:"Metrics DSL"})," section."]})}),"\n",(0,i.jsxs)(n.p,{children:["The examples in this section assume you have imported the following and have created a\n",(0,i.jsx)(n.a,{href:"/prometheus4cats/docs/interface/metric-factory",children:(0,i.jsx)(n.code,{children:"MetricFactory"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import cats.effect._\nimport prometheus4cats._\n\nval factory: MetricFactory[IO] = MetricFactory.noop[IO]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"counter",children:(0,i.jsx)(n.code,{children:"Counter"})}),"\n",(0,i.jsxs)(n.p,{children:["This implements an ",(0,i.jsx)(n.a,{href:"https://github.com/OpenObservability/OpenMetrics",children:"OpenMetrics"})," counter, allowing a number to be incremented by ",(0,i.jsx)(n.code,{children:"1"})," or some positive value."]}),"\n",(0,i.jsxs)(n.p,{children:["See the example below on how to obtain a ",(0,i.jsx)(n.code,{children:"Counter"})," from a ",(0,i.jsx)(n.a,{href:"/prometheus4cats/docs/interface/metric-factory",children:(0,i.jsx)(n.code,{children:"MetricFactory"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'factory.counter("my_counter_total").ofLong.help("Metric description")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"gauge",children:(0,i.jsx)(n.code,{children:"Gauge"})}),"\n",(0,i.jsxs)(n.p,{children:["This implements an ",(0,i.jsx)(n.a,{href:"https://github.com/OpenObservability/OpenMetrics",children:"OpenMetrics"})," gauge, allowing a number to be incremented and decremented by ",(0,i.jsx)(n.code,{children:"1"})," or some positive\nvalue, as well as reset to ",(0,i.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["See the example below on how to obtain a ",(0,i.jsx)(n.code,{children:"Gauge"})," from a ",(0,i.jsx)(n.a,{href:"/prometheus4cats/docs/interface/metric-factory",children:(0,i.jsx)(n.code,{children:"MetricFactory"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'factory.gauge("my_summary").ofLong.help("Metric description")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"histogram",children:(0,i.jsx)(n.code,{children:"Histogram"})}),"\n",(0,i.jsxs)(n.p,{children:["This implements an ",(0,i.jsx)(n.a,{href:"https://github.com/OpenObservability/OpenMetrics",children:"OpenMetrics"})," histogram, allowing a number to be recorded on a distribution of pre-defined buckets."]}),"\n",(0,i.jsxs)(n.p,{children:["See the example below on how to obtain a ",(0,i.jsx)(n.code,{children:"Histogram"})," from a ",(0,i.jsx)(n.a,{href:"/prometheus4cats/docs/interface/metric-factory",children:(0,i.jsx)(n.code,{children:"MetricFactory"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val histogram = factory\n  .histogram("my_histogram")\n  .ofDouble\n  .help("Metric description")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"user-defined-buckets",children:"User Defined Buckets"}),"\n",(0,i.jsxs)(n.p,{children:["You can set buckets statically with your own values, the type of these values must match that of the ",(0,i.jsx)(n.code,{children:"Histogram"}),"\n(either ",(0,i.jsx)(n.code,{children:"Double"})," or ",(0,i.jsx)(n.code,{children:"Long"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"histogram.buckets(0.1, 0.5, 1.0, 1.5, 2.0)\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also use pre-defined values for default HTTP timing buckets."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Note that this syntax is only available on ",(0,i.jsx)(n.code,{children:"Histogram"}),"s that record ",(0,i.jsx)(n.code,{children:"Double"})," values."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"histogram.defaultHttpBuckets\n"})}),"\n",(0,i.jsx)(n.h3,{id:"generated-buckets",children:"Generated Buckets"}),"\n",(0,i.jsx)(n.p,{children:"It is possible to generate buckets of a certain size, which is specified at compile time with a natural number."}),"\n",(0,i.jsxs)(n.p,{children:["In Scala 2, you must import Shapeless' ",(0,i.jsx)(n.code,{children:"Nat"}),", whereas in Scala 3 this will work with integers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import shapeless.Nat\n"})}),"\n",(0,i.jsx)(n.p,{children:"Linear buckets may be generated using the method below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"histogram.linearBuckets[Nat._10](start = 1, width = 3)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Exponential buckets may be generated using the method below:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Note that this syntax is only available on ",(0,i.jsx)(n.code,{children:"Histogram"}),"s that record ",(0,i.jsx)(n.code,{children:"Double"})," values."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"histogram.exponentialBuckets[Nat._5](start = 1.0, factor = 1.5)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:(0,i.jsx)(n.code,{children:"Summary"})}),"\n",(0,i.jsxs)(n.p,{children:["This implements an ",(0,i.jsx)(n.a,{href:"https://github.com/OpenObservability/OpenMetrics",children:"OpenMetrics"})," summary, allowing a number to be recorded against a calculated."]}),"\n",(0,i.jsxs)(n.p,{children:["See the example below on how to obtain a ",(0,i.jsx)(n.code,{children:"Summary"})," from a ",(0,i.jsx)(n.a,{href:"/prometheus4cats/docs/interface/metric-factory",children:(0,i.jsx)(n.code,{children:"MetricFactory"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val summary = factory\n  .summary("my_summary")\n  .ofDouble\n  .help("Metric description")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"Summary"})," metrics provide the count and the sum. For example, if you measure latencies of a REST service,\nthe count will tell you how often the REST service was called, and the sum will tell you the total aggregated response\ntime. You can calculate the average response time using a Prometheus query dividing sum / count."]}),"\n",(0,i.jsx)(n.h3,{id:"quantiles",children:"Quantiles"}),"\n",(0,i.jsxs)(n.p,{children:["In addition to count and sum, you can configure a ",(0,i.jsx)(n.code,{children:"Summary"})," to provide quantiles:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val quantileSummary = factory\n  .summary("my_summary")\n  .ofDouble\n  .help("Metric description")\n  .quantile(0.5, 0.01)    // 0.5 quantile (median) with 0.01 allowed error\n  .quantile(0.95, 0.005)  // 0.95 quantile with 0.005 allowed error\n'})}),"\n",(0,i.jsx)(n.p,{children:"As an example, a 0.95 quantile of 120ms tells you that 95% of the calls were faster than 120ms, and 5% of the calls were\nslower than 120ms."}),"\n",(0,i.jsx)(n.p,{children:"Tracking exact quantiles require a large amount of memory, because all observations need to be stored in a sorted list.\nTherefore, we allow an error to significantly reduce memory usage."}),"\n",(0,i.jsx)(n.p,{children:"In the example, the allowed error of 0.005 means that you will not get the exact 0.95 quantile, but anything between the\n0.945 quantile and the 0.955 quantile."}),"\n",(0,i.jsx)(n.p,{children:"Experiments show that the Summary typically needs to keep less than 100 samples to provide that precision, even if you\nhave hundreds of millions of observations."}),"\n",(0,i.jsx)(n.p,{children:"There are a few special cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You can set an allowed error of 0, but then the Summary will keep all observations in memory."}),"\n",(0,i.jsx)(n.li,{children:"You can track the minimum value with .quantile(0.0, 0.0). This special case will not use additional memory even though\nthe allowed error is 0."}),"\n",(0,i.jsx)(n.li,{children:"You can track the maximum value with .quantile(1.0, 0.0). This special case will not use additional memory even though\nthe allowed error is 0."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"maximum-age-and-age-buckets",children:"Maximum Age and Age Buckets"}),"\n",(0,i.jsxs)(n.p,{children:["Typically, you don't want to have a ",(0,i.jsx)(n.code,{children:"Summary"})," representing the entire runtime of the application, but you want to look\nat a reasonable time interval. Summary metrics implement a configurable sliding time window:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import scala.concurrent.duration._\n\nval ageSummary = factory\n  .summary("my_summary")\n  .ofDouble\n  .help("Metric description")\n  .maxAge(10.seconds)\n  .ageBuckets(5)\n'})}),"\n",(0,i.jsx)(n.p,{children:"The default is a time window of 10 minutes and 5 age buckets, i.e. the time window is 10 minutes wide, and we slide it\nforward every 2 minutes."}),"\n",(0,i.jsx)(n.h2,{id:"info",children:(0,i.jsx)(n.code,{children:"Info"})}),"\n",(0,i.jsxs)(n.p,{children:["This implements an ",(0,i.jsx)(n.a,{href:"https://github.com/OpenObservability/OpenMetrics",children:"OpenMetrics"})," info type, allowing labels to be registered as a sort of gauge where the value is\nalways ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val info = factory\n  .info("my_info")\n  .help("Info description")\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);